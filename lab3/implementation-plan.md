1. Указание начального узла для подключения (изначально null)
2. Запуск узла с null
3. Запуск узла с не null и подключение к системе
4. Поиск позиции подключения к кольцу
5. Поиск pred и succ для узла
6. Взаимодействие с pred и succ для подключения к кольцу и разделения данных
7. Алгоритм join и ~~balance
8. Обновление finger table
9. Формирование finger table


1. Finger Table - формирование, поиск
2. succ(k) - отдельный эндпоинт - поиск преемника для k
3. Обмен данными при подключении к кольцу
    1. Поиск отдаваемых блоков
    2. postBlock на новый узел
    3. Удаление блоков
        1. Несколько попыток на удаление блока с таймаутом
        2. Запись в лог файл неудачных удалений
    4. Пока данные передаются, перенаправляем, если файл не найден

p = successor(k) - node p is responsible for k

Новые эндпоинты:

- successor(k)
- predecessor

# successor(k)

1. Проверка на "себя".
   k лежит в (n, n.successor], значит self должен владеть блоком.
2. Обход finger table с начала до конца
   поиск node.id > k, (node.id >= k)
   1. Делегация запроса на этот узел





